package com.devappliance.i18nbuilder;

import com.devappliance.i18n.annotation.DoNotExtract;
import com.devappliance.i18nbuilder.enums.ExtractionMode;
import com.devappliance.i18nbuilder.processor.AnnotationProcessor;
import com.devappliance.i18nbuilder.processor.ClassProcessor;
import spoon.Launcher;
import spoon.SpoonAPI;
import spoon.compiler.Environment;
import spoon.reflect.CtModel;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.ModifierKind;
import spoon.reflect.factory.TypeFactory;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.reflect.declaration.CtAnnotationImpl;
import spoon.support.sniper.SniperJavaPrettyPrinter;

import java.io.*;
import java.util.*;

/**
 * @author Gibah Joseph
 * Email: gibahjoe@gmail.com
 * Apr, 2020
 */
@DoNotExtract
public class Extractor {
    private static Extractor INSTANCE = new Extractor();
    private Config config = new Config();
    private Properties properties;

    public static Extractor getExtractor() {
        return INSTANCE;
    }

    public Config getConfig() {
        return config;
    }

    public Properties getProperties() {
        return properties;
    }

    public Extractor addProperty(String key, String value) {
        this.properties.setProperty(key, value);
        return this;
    }

    public SpoonAPI run() {
        SpoonAPI launcher = new Launcher();
        Environment environment = launcher.getEnvironment();
        properties = loadPropertiesFile(environment);

        if (!getConfig().isRewriteEntireClass()) {
            launcher.getEnvironment().setPrettyPrinterCreator(() -> {
                SniperJavaPrettyPrinter sniperJavaPrettyPrinter = new SniperJavaPrettyPrinter(launcher.getEnvironment());
                return sniperJavaPrettyPrinter;
            });
        }

        environment.setNoClasspath(true);
        environment.setAutoImports(true);

        getConfig().inputResources.stream().forEach((s) -> {
            launcher.addInputResource(s);
        });
        launcher.setSourceOutputDirectory(getConfig().sourceOutputDirectory);

//        environment.setLevel(Level.DEBUG.name());
        CtModel ctModel = launcher.buildModel();
        List<CtType<?>> keyHolderClassMatches = ctModel.getElements(new TypeFilter<CtType<?>>(CtType.class) {
            @Override
            public boolean matches(CtType<?> element) {
                return element.getQualifiedName().equals(getConfig().translationKeyHolderClass);
            }
        });
        CtType<?> messagesClass = keyHolderClassMatches.size() > 0 ? keyHolderClassMatches.get(0) : null;
        if (messagesClass == null) {
            String baseClassFqn = getConfig().translationKeyHolderClass;
            messagesClass = launcher.getFactory().createClass(baseClassFqn);
            messagesClass.addModifier(ModifierKind.PUBLIC);
            environment.debugMessage("===> Generated translation key holder at " + messagesClass.getPath().toString());
        }
        if (!messagesClass.hasAnnotation(DoNotExtract.class)) {
            CtAnnotation annotation = new CtAnnotationImpl();
            annotation.setAnnotationType(new TypeFactory().get(DoNotExtract.class).getReference());
            messagesClass.addAnnotation(annotation);
        }

        List<String> processedPackages;
        if (getConfig().getMode() == ExtractionMode.ANNOTATED) {
            AnnotationProcessor processor = new AnnotationProcessor(messagesClass, launcher);
            launcher.addProcessor(processor);
            launcher.process();
            processedPackages = processor.getProcessedPackages();
        } else {
            ClassProcessor processor = new ClassProcessor(messagesClass, launcher);
            launcher.addProcessor(processor);
            launcher.process();
            processedPackages = processor.getProcessedPackages();
        }
        processedPackages.add(getConfig().translationKeyHolderClass);
        launcher.setOutputFilter(processedPackages.toArray(new String[]{}));
        try {
            exportProps(environment);
            launcher.prettyprint();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return launcher;
    }

    private void exportProps(Environment environment) throws IOException {
        File outputFile = new File(getConfig().translationKeysOutputFile);
        if (!outputFile.exists()) {
            outputFile.getParentFile().mkdirs();
        }
        try (FileOutputStream fileOutputStream = new FileOutputStream(outputFile)) {
            properties.store(fileOutputStream, "This file is autogenerated. DO NOT MODIFY BY HAND");
        }
    }

    private Properties loadPropertiesFile(Environment environment) {
        Properties prop = new Properties();
        try (InputStream in = new FileInputStream(getConfig().translationKeysOutputFile)) {
            prop.load(in);
        } catch (IOException e) {
            environment.debugMessage("===> Unable to read Key output file at " + getConfig().translationKeysOutputFile + " generating a new one...");
        }
        return prop;
    }

    @DoNotExtract
    public static class Config {
        private Set<String> inputResources = new HashSet<>();

        private String translationKeyHolderClass;

        private String translationKeysOutputFile = "src/main/resources/messages.properties";

        private String sourceOutputDirectory = "build/generated/sources/i18n/java";

        //        private List<String> keyHolderFieldNameCharacterBlacklist = Arrays.asList("/", "$", " ", "#", "-", "=", "%", "{", "}");
//        private List<String> blacklistKeyCharacters = Arrays.asList("/", " ");
        private List<String> excludeTypeLiterals = new ArrayList<>();
        private List<String> excludePackages = new ArrayList<>();
        private ExtractionMode mode = ExtractionMode.ALL;
        private boolean rewriteEntireClass = true;

        public Config() {
            excludeTypeLiterals.add("org.springframework.web.bind.annotation.*");
        }

        public List<String> getExcludePackages() {
            return excludePackages;
        }

        public Config setExcludePackages(List<String> excludePackages) {
            this.excludePackages = excludePackages;
            return this;
        }

        public boolean isRewriteEntireClass() {
            return rewriteEntireClass;
        }

        public Config setRewriteEntireClass(boolean rewriteEntireClass) {
            this.rewriteEntireClass = rewriteEntireClass;
            return this;
        }

        public ExtractionMode getMode() {
            return mode;
        }

        public Config setMode(ExtractionMode mode) {
            this.mode = mode;
            return this;
        }

        public List<String> getExcludeTypeLiterals() {
            return excludeTypeLiterals;
        }

        /***
         * Exclude string literals that appear in annotations
         * @param excludeTypeLiterals List fully qualified name of annotations to exclude from extraction
         * @return the builder
         */
        public Config setExcludeTypeLiterals(List<String> excludeTypeLiterals) {
            this.excludeTypeLiterals = excludeTypeLiterals;
            return this;
        }

        public String getSourceOutputDirectory() {
            return sourceOutputDirectory;
        }

        public Config setSourceOutputDirectory(String sourceOutputDirectory) {
            this.sourceOutputDirectory = sourceOutputDirectory;
            return this;
        }

//        public List<String> getKeyHolderFieldNameCharacterBlacklist() {
//            return keyHolderFieldNameCharacterBlacklist;
//        }
//
//        public Config setKeyHolderFieldNameCharacterBlacklist(List<String> keyHolderFieldNameCharacterBlacklist) {
//            this.keyHolderFieldNameCharacterBlacklist = keyHolderFieldNameCharacterBlacklist;
//            return this;
//        }

        public Set<String> getInputResources() {
            return inputResources;
        }

//        public List<String> getBlacklistKeyCharacters() {
//            return blacklistKeyCharacters;
//        }
//
//        public Config setBlacklistKeyCharacters(List<String> blacklistKeyCharacters) {
//            this.blacklistKeyCharacters = blacklistKeyCharacters;
//            return this;
//        }

        public void addInputFolders(String inputFolder) {
            this.inputResources.add(inputFolder);
        }

        public String getTranslationKeyHolderClass() {
            return translationKeyHolderClass;
        }

        public void setTranslationKeyHolderClass(String translationKeyHolderClass) {
            this.translationKeyHolderClass = translationKeyHolderClass;
        }

        public String getTranslationKeysOutputFile() {
            return translationKeysOutputFile;
        }

        public void setTranslationKeysOutputFile(String translationKeysOutputFile) {
            this.translationKeysOutputFile = translationKeysOutputFile;
        }
    }
}
